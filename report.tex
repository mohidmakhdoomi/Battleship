\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{amsfonts}

\usepackage[T1]{fontenc}
\usepackage{fullpage}
\usepackage{titling}
\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{color}
\usepackage[dvipsnames]{xcolor}
\usepackage{tabularx,ragged2e}
\newcommand\tab[1][0.5in]{\hspace*{#1}}


\lstset{
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  basicstyle=\small\ttfamily,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{Red},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  % escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{BurntOrange},       % keyword style
  language=python,                 % the language of the code
  morekeywords={*,...},           % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (None, left, right)
  numbersep=10pt,                   % how far the line-numbers are from the code
  numberstyle=\color{Gray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=5,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{Green},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the fishipSizeame of files included with \lstinputlisting; also try caption instead of title
}

\usepackage{ifpdf}
\ifpdf
  \usepackage[pdftex,pagebackref=true]{hyperref}
\else
  \usepackage[ps2pdf,pagebackref=true]{hyperref}
\fi
\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  citecolor=Brown,
  unicode=true,
  filecolor=Purple,      
  urlcolor=cyan,
  pdftitle={CS 2ME3 Assignment 4 Report},
  pdfauthor={Mohid Makhdoomi - makhdoom},
  pdfstartpage=1,
}

\title{CS 2ME3 Assignment 4 Report}
\author{Mohid Makhdoomi - makhdoom}

\renewcommand*\contentsname{Table of Contents}

\begin{document}
\makeatletter
\vspace*{8em}
\noindent
\hfil\parbox[t]{1\textwidth}{\centering\Huge\bfseries{CS 2ME3}\\[0.5ex]{Assignment 4 Report}}\par
\kern0.6cm \hrule\kern0.4cm
\noindent
\hfil\parbox[t]{1\textwidth}{\centering\large\bfseries\@author\\[2ex]\@date}\par
\kern0.3cm \hrule\kern0cm
\makeatother
\newpage
%
%{\centering
%  \tableofcontents\par
%}
%\addtocontents{toc}{\protect\vspace{2.5em}}
\newpage

\section* {Constants Module}

\subsection*{Module}

Constants

\subsection* {Uses}

N/A

\subsection* {Syntax}

\subsubsection* {Exported Constants}

MAX\_GRID = 10 {\it //max length in the x-direction and y-direction of the grid}\\
MIN\_SIZE = 2 {\it //minimum ship size}\\
MAX\_SIZE = 5 {\it //maximum ship size}

\subsubsection* {Exported Access Programs}

None

\subsection* {Semantics}

\subsubsection* {State Variables}

None

\subsubsection* {State Invariant}

None

\newpage

\section* {Point ADT Module}

\subsection*{Template Module}

PointT

\subsection* {Uses}

Constants

\subsection* {Syntax}

\subsubsection* {Exported Types}

PointT = ?

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
PointT & integer, integer & PointT & InvalidPointException\\
\hline
xcrd & ~ & integer & ~\\
\hline
ycrd & ~ & integer & ~\\
\hline
dist & PointT & real & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$xc$: integer\\
$yc$: integer

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}
The constructor PointT is called for each abstract object before any other access routine is called for that
object.  The constructor cannot be called on an existing object.

\subsubsection* {Access Routine Semantics}

PointT($x, y$):
\begin{itemize}
\item transition: $xc, yc := x, y$
\item output: $out := \mathit{self}$
\item exception:
 $exc := ((\neg(0 \leq x \leq \mbox{Contants.MAX\_GRID}) \vee \neg(0 \leq y \leq \mbox{Constants.MAX\_GRID})) \Rightarrow
\mbox{InvalidPointException})$
\end{itemize}

\noindent xcrd():
\begin{itemize}
\item output: $out := xc$
\item exception: None
\end{itemize}

\noindent ycrd():
\begin{itemize}
\item output: $out := yc$
\item exception: None
\end{itemize}

\noindent dist($p$):
\begin{itemize}
\item output: $out := \sqrt{(\mathit{self}.xc - p.xcrd())^2 + (\mathit{self}.yc - p.ycrd())^2}$
\item exception: None
\end{itemize}

\newpage

\section* {Ship ADT Module}

\subsection*{Template Module}

ShipT

\subsection* {Uses}

Constants, PointT

\subsection* {Syntax}

\subsubsection* {Exported Types}

ShipT = ?

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
ShipT & PointT, PointT, integer & ShipT & InvalidShipException\\
\hline
startPoint & ~ & PointT & ~\\
\hline
endPoint & ~ & PointT & ~\\
\hline
shipSize & ~ & integer & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$start$: PointT\\
$end$: PointT\\
$length$: integer

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}
The constructor ShipT is called for each abstract object before any other access routine is called for that
object.  The constructor cannot be called on an existing object.

\subsubsection* {Access Routine Semantics}

ShipT($one, two, length$):
\begin{itemize}
\item transition: $start, end, length := one, two, length$
\item output: $out := \mathit{self}$
\item exception:
 $exc := (((length < \mbox{Constants.MIN\_SIZE}) \lor (length > \mbox{Constants.MAX\_SIZE}) \lor (one.\mbox{dist}(two) \neq length) \lor ((one.\mbox{xcrd}() \neq two.\mbox{xcrd}()) \land (one.\mbox{ycrd}() \neq two.\mbox{ycrd}())))\Rightarrow
\mbox{InvalidShipException})$
\end{itemize}

\noindent startPoint():
\begin{itemize}
\item output: $out := start$
\item exception: None
\end{itemize}

\noindent endPoint():
\begin{itemize}
\item output: $out := end$
\item exception: None
\end{itemize}

\noindent shipSize():
\begin{itemize}
\item output: $out := length$
\item exception: None
\end{itemize}

\newpage

\section* {Game State ADT Module}

\subsection* {Template Module}

GameStateT

\subsection* {Uses}

Constants, PointT, ShipT

\subsection* {Syntax}

\subsubsection* {Exported Types}
GameStateT = ?

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{5cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
GameStateT & sequence of ShipT & GameStateT & InvalidShipListException\\
\hline
is\_hit & PointT & boolean & ~\\
\hline
is\_all\_sunk & ~ & boolean & ~\\
\hline

\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}
$ships$: sequence of ShipT\\
$hits$: sequence of integer

\subsubsection* {State Invariant}
None

\subsubsection* {Assumptions}
The GameStateT() constructor is called for each abstract object before any other access routine is called for that
object.  The constructor can only be called once.

\subsubsection* {Access Routine Semantics}

\noindent GameStateT($shipList$):
\begin{itemize}
\item transition: $ships, hits := shipList, <0, 0, 0, 0, 0>$
\item output: $\mathit{out} := \mathit{self}$
\item exception: 
\begin{eqnarray*}
\lefteqn{exc := ((|shipList| \neq 5) \lor (shipList[0].\mbox{shipSize()} \neq 2)  \lor (shipList[1].\mbox{shipSize()} \neq 3)  \lor}\\
& &  (shipList[2].\mbox{shipSize()} \neq 3)  \lor (shipList[3].\mbox{shipSize()} \neq 4)  \lor (shipList[4].\mbox{shipSize()} \neq 5)  \lor\\
& &  (\exists( i : \mathbb{I} | 0 \leq i < |shipList| : \exists( j : \mathbb{I} | (0 \leq j < |shipList|) \land (i \neq j) :\\
& &  \mbox{collision}(shipList[i], shipList[j]))))) \Rightarrow \mathrm{InvalidShipListException}
\end{eqnarray*}
\end{itemize}

\noindent is\_hit($p$):
\begin{itemize}
\item transition-output: $hits, out := $\\\tab$(\mbox{hitCheck}(ships, p) \Rightarrow hits[0..i-1] ||\mathit{<}pre(hits)[i] + 1\mathit{>}|| hits[i + 1 .. |hits| -1 ]$ \\\tab\tab where $\mbox{pointInLine}(p, ships[i].\mbox{startPoint}(), ships[i].\mbox{endPoint}()) = true$\\\tab$|  \lnot \mbox{hitCheck}(ships, p) \Rightarrow hits),$\\$\mbox{hitCheck}(ships, p)$
\item exception: None
\end{itemize}


\noindent is\_all\_sunk():
\begin{itemize}
\item output: $out := \forall( i : \mathbb{I} | 0 \leq i < |ships| : ships[i].\mbox{shipSize}() = hits[i])$
\item exception: None
\end{itemize}
%
%\subsubsection* {Local Types}
%
%boardT = sequence [Constants.MAX\_GRID, Constants.MAX\_GRID] of boolean

\subsubsection* {Local Functions}

\noindent \textbf{hitCheck} : sequence of ShipT $\times$ PointT $\rightarrow$ boolean\\
~\newline
hitCheck$(shipList, p) \equiv \exists( s : ShipT | s \in shipList : \mbox{pointInLine}(p, s.\mbox{startPoint}(), s.\mbox{endPoint}()))$

~\newline

\noindent \textbf{collision} : ShipT $\times$ ShipT $\rightarrow$ boolean\\
~\newline
collision$(one, two) \equiv \exists( i : \mbox{PointT} | \mbox{pointInLine}(i, one.\mbox{startPoint}(), one.\mbox{endPoint}()) :$\\\tab\tab\tab\tab\tab$ \mbox{pointInLine}(i, two.\mbox{startPoint}(), two.\mbox{endPoint}()))$

~\newline

\noindent \textbf{pointInLine} : PointT $\times$ PointT $\times$ PointT $\rightarrow$ boolean\\
~\newline
pointInLine$(p, start, end) \equiv (start.\mbox{dist}(p) + end.\mbox{dist}(p) = start.\mbox{dist}(end))$

~\newline

\newpage

\section* {Battleship Module}

\subsection* {Module}

Battleship

\subsection* {Uses}

Constants, PointT, ShipT, GameStateT

\subsection* {Syntax}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{5cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
init & sequence of ShipT, & ~ & ~\\
~ & sequence of ShipT & ~ & ~\\
\hline
add\_shot & PointT & boolean & InvalidMoveException\\
\hline
get\_shots & ~ & sequence of PointT & ~\\
\hline
has\_won & ~ & boolean & ~\\
\hline

\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$\mathit{player1}$: GameStateT\\
$\mathit{player2}$: GameStateT\\
$shotList$: sequence of PointT\\
$\mathit{player1turn}$: boolean

\subsubsection* {Assumptions}

The init method is called for the abstract object before any other access routine is called for that
object.  The init method can be used to return the state of the game to the state of a new game.

\subsubsection* {Access Routine Semantics}

init($\mathit{player1ships}, \mathit{player2ships}$):
\begin{itemize}
\item transition: $\mathit{player1},\mathit{player2}, shotList, \mathit{player1turn} := \mbox{new GameStateT}(\mathit{player1ships}), \\\mbox{new GameStateT}(\mathit{player2ships}), <>,  true$
\item exception: None
\end{itemize}
~\newline
\noindent add\_shot($p$):
\begin{itemize}
\item transition-output: $player1turn, out := \lnot player1turn$ and $shotList$ such that $shotList = pre(shotList)[0..|pre(shotList)|-1]||\mathit{<}p\mathit{>}, (player1turn \Rightarrow player2.\mbox{is\_hit}(p) | \lnot player1turn \Rightarrow player1.\mbox{is\_hit}(p))$
\item exception: $exc := (player1turn \Rightarrow \exists( i : \mathbb{I} | (i \% 2 = 0) \land (0 \leq i < |shotList|) : samePoint(p, shotList[i]))| \lnot player1turn \Rightarrow \exists( i : \mathbb{I} | (i \% 2 = 1) \land (0 \leq i < |shotList|) : samePoint(p, shotList[i]))) \Rightarrow$ InvalidMoveException
\end{itemize}

\noindent get\_shots():
\begin{itemize}
\item output: $out := shotList[0..|shotList| -1]$
\item exception: None
\end{itemize}

\noindent has\_won():
\begin{itemize}
\item output: $out := (player1turn \Rightarrow player2.\mbox{is\_all\_sunk()}| \lnot player1turn \Rightarrow player1.\mbox{is\_all\_sunk()})$
\item exception: None
\end{itemize}

\subsubsection* {Local Functions}
\textbf{samePoint} : PointT $\times$ PointT $\rightarrow$ boolean\\
~\newline
samePoint($p_1,p_2$) $\equiv (p_1.\mbox{xcrd}() = p_2.\mbox{xcrd}()) \land (p_1.\mbox{ycrd}() = p_2.\mbox{ycrd}())$

~\newline

\end{document}